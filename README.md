# lab3
Шаломина Александра ПМ-2401. Вариант: 29
## Cодержание

1. [Отчет по лабораторной работе №](#отчет-по-лабораторной-работе--n)
2. [Критерии оценивания](#критерии-оценивания)

## Отчет по лабораторной работе № 3

#### № группы: `ПМ-2401`
#### Выполнил: `Шаломина Адександра Тимофеевна`
#### Вариант: `29`

### Cодержание:

- [Постановка задачи](#1-постановка-задачи)
- [Входные и выходные данные](#2-входные-и-выходные-данные)
- [Выбор структуры данных](#3-выбор-структуры-данных)
- [Алгоритм](#4-алгоритм)
- [Программа](#5-программа)
- [Анализ правильности решения](#6-анализ-правильности-решения)

### 1. Постановка задачи

    Разработать программу для работы с массивом постов, где каждый пост содержит
    текст, автора и количество лайков. Реализовать функции добавления, удаления, анализа постов и обработки данных об авторах.



  - нужно создать класс Account, в котором будут содержаться данный о конкретном посте пользователя (имя, текст поста, количество лайков поста)
  - в классе Account нужно написать методы (get и set), тут я решила писать не все возможные, а только те, которые помогут мне в решении поставленной задачи
  - теперь нужно создать класс Posts, который будет являться массивом всех постов пользователей
  - в классе Posts, нужно описать методы из задания
  - Далее нужно создать класс Test, в котором проверить корректность работы программы.
### 2. Входные и выходные данные
На вход программе нужно описать несколько переменных класса Account, и создать массив с ними. После этого описать переменную класса Posts, которая будет являться созданным ранее массивом
#### Данные на выход
На выход в разных методах будут подаваться разные типы данных, такие как int, String, Account, а в каких то методах внутри методов будет изменяться значение переменной, поэтому выходных данных нет.


### 3. Выбор структуры данных

в программе существует два класса:
 1. Account, в котором для хранения имени пользователя используется тип данных String, для хранения текста поста используется String, для хранения количества лайков используется int.
2. Posts, в котором для хранения всех постов используется массив, заданной длины(т.к. динамическими массивами пользоваться нельзя), типа данных Account

### 4. Алгоритм

1. **Account**  
    - создание приватных полей этого класса
   - описание конструктора
   - описание метода по добавлению лайка посту (обращение к полю типа int и увеличение его на 1)
   - описание метода по возвращению имени пользователя (обращение к полю)
   - описание метода по возвращению количества лайков (обращение к полю)
    
2. **Posts**  
    - создание приватных полей этого класса (поле класса указывается максимальное количество постов, которое может храниться в одной переменной этого класса)
    - описание конструктора (т.к. в задании требуется выводить посты с последнего добаленного, то массив постов инициализируется исходным массивом в обратном порядке)
    - описание метода по добавлению нового поста (тут надо сместить каждый пост на соседнее место в массиве, а на первое место добавить новый пост)
    - описание метода по возвращению лайка посту (тут надо обратиться к посту с указанным номером и добавить ему лайк по методу из класса Account)
   - описание метода по добавлению лайка посту (тут надо обратиться к посту с указанным номером и вернуть его количество лайков по методу из класса Account)
   - описание метода по удалению поста (тут нужно перечислить значения массива с указанного номера, не включая его, для этого все элементы с этого номера надо сместить на один, и  чтобы последний элемент не повторился присвоить последнему элементу списка null)
   - описание метода по выводу постов с количеством лайков больше указанного(перебор ненулевых элементов и вывод постов с количеством лайков больше заданного)
   - описание метода по нахождению самого популярного поста (перебор всех элементов и поиск того у которого максимальное количество лайков)
   - описание метода по выводу постов с количеством одинакового автора (сравнение автора каждого элемента с подаваемой строк и вывод поста при совпадении)
   - описание метода по удалению постов автор с указанным номером (сравнение автора элемента с поданым строковым значением и подсчет количества его встречания в массиве, при совпадении количества с поданым значением, перечисление элементов без этого поста  )
   - описание метода по удалению всех постов указанного автора (подсчет всех постов автора, после этого удаление каждого отдельного поста с помощью прохождения цикла по массиву )
   - описание метода по возвращению суммы лайков у автора (сравнение автора поста с указанным значением, при совпадении прибавление количества лайков к сумме)
   - описание метода по выводу всех авторов(проверка каждого автора на уникальность, если автор встречается первый раз, то записать его имя в список и в итоге вернуть список )
   - описание метода подсчету самого популярного автора(подсчет лайков каждого автора и нахождения максимального количества лайков среди всех остальных авторов )
3. **Test**
  - создание переменных
  - инициализация массива
  - создание переменной класса Posts
  - поочередная проверка каждого метода из класса Posts
4. **Вывод результата:**

### 5. Программа

```java
import java.io.PrintStream;
import java.util.Scanner;
class Account {
    private String name;// имя автора
    private String tekst; // текст автора
    private int like;// количество лайков

    public Account(String name, String tekst, int like) {
        if (name.length() != 0)
            this.name = name;
        if (tekst.length() <= 70)
            this.tekst = tekst;
        this.like = like;
    }

    public void addLike() {
        like += 1;
    }

    public int getLike() {
        return like;
    }

    public String getName() {
        return name;
    }

    @Override
    public String toString(){
        return ("автор: "+name+"\nтекст: "+tekst+"\nколичество лайков: "+like+"\n");

    }
}
class Posts{
    private Account [] data = new Account[1000];

    public Posts ( Account [] people) {
        int k = people.length;
        for (int i = k-1; i >=0; i--) {
            data[i] = people[k-1-i];
        }
    }

    public void addPerson(Account person){
        Account t = data[0];
        for (int i = 1; i < data.length; i++) {
            Account tt= data[i];
            data[i]=t;
            t=tt;
        }
        data[0]=person;
    }

    public int getLikeofPerson(int t ){
        return data[t-1].getLike();
    }

    public void addLiketoPerson (int t){
        data[t-1].addLike();
    }

    public void delitePost( int t ){
        for (int i = t-1; i < data.length-1 ; i++) {
            data[i]=data[i+1];
        }
        data[data.length-1]=null;
    }

    public void moreLikethen(int t ){
        for (int i = 0; i < data.length; i++) {
            if (data[i]!=null){
                if (data[i].getLike()>t )
                    System.out.println(data[i]);
            }

        }
    }

    public Account themostPopularPost(){
        Account t = data[0];
        int max = 0;
        for (int i = 0; i < data.length; i++) {
            if (data[i]!=null){
                if (data[i].getLike()>max){
                    max=data[i].getLike();
                    t=data[i];
                }
            }
        }
        return t;
    }

    public void postwithSemiA(String name){
        for (int i = 0; i < data.length; i++) {
            if (data[i]!=null){
                if (data[i].getName().equals(name))
                    System.out.println(data[i]);
            }

        }
    }

    public void deliteAforN(String name,int t){
        int kol=0;
        int index = -1;
        for (int i = 0; i < data.length; i++) {
            if (data[i]!=null){
                if (data[i].getName().equals(name)){
                    kol++;
                    if (kol==t){
                        index=i;
                    }


                }
            }
        }
        for (int i = index; i < data.length-1; i++) {
            data[i]=data[i+1];
        }
        data[data.length-1]=null;
    }

    public void deliteAvtor(String name){
        int reskol=0;
        for (int i = 0; i < data.length; i++) {
            if (data[i] != null) {
                if (data[i].getName().equals(name)) {
                    data[i] = null;
                    reskol++;
                }
            }
        }
        for (int i = 0; i < reskol; i++) {
            int kol=0;
            int index= data.length;
            for (int j = 0; j < data.length-1; j++) {
                if (data[j]==null && kol==0){
                    kol++;
                    index=j;}
                if (j>=index)
                    data[j]=data[j+1];
            }
        }
    }

    public int sumLikeofAvtor(String name){
        int sum=0;
        for (int i = 0; i < data.length; i++) {
            if (data[i]!=null){
                if (data[i].getName().equals(name)){
                    sum+=data[i].getLike();
                }
            }
        }
        return sum;
    }

    public String allAvtors(){
        String s = "";
        for (int i = 0; i < data.length ; i++) {
            if (data[i] != null) {
                int kol = 0;
                for (int j = i - 1; j >=0; j--) {
                    if (data[j] != null)
                        if (data[i].getName().equals(data[j].getName()))
                            kol++;
                }
                if (kol == 0)
                    s += data[i].getName() + "\n";
            }
        }
        return s;
    }

    public String theMostPopularAvtor(){
        int maxsum=0;
        Account best = data[0];
        for (int i = 0; i < data.length; i++) {
            if (data[i] != null) {
                int max = 0;
                for (int j = 0; j < data.length; j++) {
                    if (data[j] != null) {
                        if (data[j].getName().equals(data[i].getName())) {
                            max += data[j].getLike();
                        }
                    }
                }
                if (max > maxsum) {
                    maxsum = max;
                    best = data[i];
                }
            }
        }
        return best.getName();
    }

    @Override
    public String toString(){
        String s ="";
        int kol=0;
        for (int i = 0; i < data.length; i++) {
            if (data[i]!=null)
                s+=data[i]+"\n";
            else
                kol++;
        }
        return String.format(s+"%d (из %d) постов можно еще разместить\n",kol,data.length);
    }

}
public class Test {
    public static Scanner in = new Scanner(System.in);
    public static PrintStream out = System.out;
    public static void main(String[] args) {
        Account p1 = new Account("sasha","privet", 76);
        Account p2 = new Account("mama","syp", 3475);
        Account p3 = new Account("papa","molotok", 36);
        Account p4 = new Account("babushka","pirogi", 3476);
        Account p5 = new Account("dedushka","garazh", 6);

        Account [] people= new Account[5];
        people[0]=p1;
        people[1]=p2;
        people[2]=p3;
        people[3]=p4;
        people[4]=p5;

        Posts p=new Posts(people);
        //out.println(p); //проверка метода 1-вывод постов в обратном порядке

        Account p6 = new Account("mama","kotleta", 123);
        p.addPerson(p6);// провекра метода 2 - добавление поста

        p.addLiketoPerson(6); // проверка метода 3 - добавление лайка посту
        //out.println(p);

        int like= p.getLikeofPerson(3); // проверка метода 4 - возврат количества лайков у поста
        //out.println(like);

        p.delitePost(4); // проверка метода 5 - удаление поста по номеру
        out.println(p);

        //p.moreLikethen(100);// проверка метода 6 - вывод постов с лайками больше указанного числа

        //out.println(p.themostPopularPost()); // проверка метода 7 - вывод самого популярного поста

        //p.postwithSemiA("mama");// проверка метода 8 - посты определённого автора

        //p.deliteAforN("mama",1);
        //out.print(p);// проверка метода 9 - удаление поста по автору и номеру

        //p.deliteAvtor("mama");
        //out.println(p); // проверка метода 10 - удаление всех постов автора

        out.println(p.sumLikeofAvtor("mama"));// проверка метода 11 - суммарное количество лайков автора

        out.println(p.allAvtors());// проверка метода 12 - список авторов сверху вниз

        out.println(p.theMostPopularAvtor());// проверка метода 13 - автор с наибольшим количеством лайков
    }
}
```
### 5. Математическая модель

 В своей программе я не использую никаких формул, кроме поиска модуля

### 6. Анализ правильности решения

1. писание правильности решение приведено в классе Test 
# Критерии оценивания

Обратите внимание на то, что лабораторная работа должна быть выложена в отдельный репозиторий с названием LabN (N -
Номер лабы). В репозитории должно быть минимум 2 файла (README.md - отчет, Main.java - код лабы)

| **Критерий**                                                                                                                                                                           | **Баллы**       |
|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-----------------|
| **Корректность программы**                                                                                                                                                             | **0** - **40**  |
| - Программа полностью выполняет задачу                                                                                                                                                 | 15              |
| - Нет ошибок выполнения                                                                                                                                                                | 10              |
| - Учтены все ограничения                                                                                                                                                               | 5               |
| - Правильное поведение в "крайних" случаях                                                                                                                                             | 10              |
|                                                                                                                                                                                        |                 |
| **Оптимизация кода**                                                                                                                                                                   | **0** - **20**  |
| - Эффективные алгоритмы                                                                                                                                                                | 10              |
| - Избежание избыточности и повторов                                                                                                                                                    | 5               |
| - Разумность использования структур данных                                                                                                                                             | 5               |
|                                                                                                                                                                                        |                 |
| **Читабельность и стиль кода**                                                                                                                                                         | **0** - **20**  |
| - Соблюдение стандартов форматирования                                                                                                                                                 | 5               |
| - Наличие комментариев, в полном объеме поясняющих написанный код                                                                                                                      | 10              |
| - Понятные имена переменных и функций                                                                                                                                                  | 5               |
|                                                                                                                                                                                        |                 |
| **Оформление отчета**                                                                                                                                                                  | **0** - **20**  |
| - Соблюдение структуры отчета                                                                                                                                                          | 5               |
| - Отчет загружен на GitHub в репозиторий с названием LabN (N - номер лабораторной работы), отчет в формате Markdown с названием README.md, также есть файл Main.java с кодом программы | Обязательно     |
| - Четкое описание алгоритма (блок-схема если нужна)                                                                                                                                    | 5               |
| - Полнота покрытия тестами всех случаев                                                                                                                                                | 5               |
| - Обоснования использования алгоритма, структур данных                                                                                                                                 | 5               |
|                                                                                                                                                                                        |                 |
| **Общая сумма**                                                                                                                                                                        | **0** - **100** |


